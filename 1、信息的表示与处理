一、基本运算

1、大端模式与小端模式
大端模式：高字节的数据存放在低地址
小端模式：高字节的数据存放在高地址

容易出错的情况：
（1）小端模式的机器与大端模式的机器通信
（2）阅读内存
（3）类型转换
类型转换：
#include<stdio.h> 
typedef unsigned char *byte_pointer;

void show_bites(byte_pointer start, size_t len){
	size_t i;
	for(i=0;i<len;i++)
		printf("%.2x",start[i]);
	printf("\n");
}

void show_int(int x){
	show_bites((byte_pointer) &x,sizeof(x));
}

void show_float(float x){
	show_bites((byte_pointer) &x, sizeof(x));
}

void show_pointer(void *x){
	show_bites((byte_pointer) &x, sizeof(x));
}

void test_show_bytes(int val){
	int ival=val;
	float fval=(float)val;
	int *pval=&val;
	
	show_int(ival);
	show_float(fval);
	show_pointer(pval);
}
		
int main(){
	test_show_bytes(0x123456);
	return 0;
}

2、逻辑运算（&&、||、！）与位级运算（&、|、~取反、^异或）
如果对第一个参数求值就能确定表达式结果，那么逻辑运算符就不会对第二个参数求值

3、移位运算
左移：舍弃最高位，补零
逻辑右移：最高位补零，最低位舍弃
算术右移：最高位补有效位（符号位）

二、整数篇

4、补码
无符号数：求和（权重*对应位的值）

补码：-最高位值*权重+求和（权重*对应位的值）

几乎所有机器都用补码表示有符号数，注意补码的不对称性可能会导致BUG

C库的头文件:<limits.h>定义了一组常量，来限定编译器运行：
INT_MAX, INT_MIN, UNIT_MAX....

java中单字节数据类型不是char而是byte

5、有符号数与无符号数之间的转换
数值可能会发生改变，但是位模式不变

例如：
无符号：11111111（8个1）数值为255
转为有符号数：11111111（8个1）数值为：-1

6、逻辑运算（比较大小）中，如果参与运算的两个数，一个是无符号数，另一个是有符号数：
此时C语言会将有符号数隐式转为无符号数，并且假设这两个数都是非负的

表达式                                               类型                              求值
-1             <              0U                    无符号                              0
2147483647U    >   -2147483647-1                    无符号                              0
2147483647     >   -2147483647-1                    有符号                              1
2147483647     >   (int)2147483648U                 有符号                              1

出错的原因就在于在运算过程中出现了隐式转换

7、增加位数

零扩展
符号扩展

8、截断数字

int 强制转换为 short

无符号：
截断k位数字（将数字长度从原来的w变为k）
假设原来值为x，截断后为x1，那么：x1=x mod 2^k

有符号：
截断k位，也有与无符号数相似的属性，只不过需要将最高位变为符号位：
实际效果是将最高位的权重从2^k-1变为-2^k-1
过程：将有符号数视为无符号数进行截断，再用强制类型转换将截断后的值转为有符号数

9、x < y 与 x - y < 0的区别
首先，这两个表达式可能会产生不同的结果：
（1）x是正整数，y是负整数，x < y 一定会返回0，但是x - y < 0就不一定了，实际上表达式的左边等于两个正整数相加，其结果不一定是正数（溢出）

10、无符号数加法（w位）
（1）正常情况
（2）上限溢出：对2^w取余（减去2^w）
s=x+y
检测溢出：s < x

11、补码加法
溢出时，采用截断方法，截取w位
正溢出：s-2^w
负溢出：s+2^w
